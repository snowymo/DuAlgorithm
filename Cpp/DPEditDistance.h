#pragma once
#include "common.h"

namespace DPEditDistance {
	// 72. Edit Distance
	// Given two words word1 and word2, find the minimum number of operations required to convert word1 to word2.
	// Operations: insert, delete, and replace
	int minDistance(string word1, string word2) {
		const int n = word1.size(), m = word2.size();
		if (n == 0 && m == 0)
			return 0;

		vector<vector<int>> f(n + 1, vector<int>(m + 1));

		for (int i = 0; i <= n; ++i) 
			f[i][0] = i;
		for (int j = 0; j <= m; ++j) 
			f[0][j] = j;

		for (int i = 1; i <= n; ++i) {
			for (int j = 1; j <= m; ++j) {
				if (word1[i - 1] == word2[j - 1]) {
					f[i][j] = f[i - 1][j - 1];
				}
				else {
					f[i][j] = min(min(f[i - 1][j], f[i][j - 1]), f[i - 1][j - 1]) + 1;
				}
			}
		}
		return f[n][m];
	}
	// Mine, I wonder why I was wrong when I just create a n*m vector to store the result. Probably calculate either the first row or column wrong.
	 int minDistance(string word1, string word2) {
		int s1 = word1.size();
		int s2 = word2.size();
		vector<vector<int>> cache (s1+1, vector<int>(s2+1));
		for(int i = 0; i <= s1; i++)
		    cache[i][0] = i;
		for(int i = 1; i <= s2; i++)
		    cache[0][i] = i;

		for(int i = 1; i <= s1; i++){
		    for(int j = 1; j <= s2; j++){
			if(word1[i-1] == word2[j-1]){
				cache[i][j] = cache[i-1][j-1];

			}else{

				cache[i][j] = min(cache[i-1][j-1],min(cache[i][j-1], cache[i-1][j]))+1;
			}
			//cout << "cache["<<i<<"]["<<j <<"]=" << cache[i][j] << "\n";
		    }
		}
		return cache[s1][s2];
	    }

	// 161. Edit Distance
	// Given two strings S and T, determine if they are both one edit distance apart.
	bool isOneEditDistance(string s, string t) {
		int n = (int)s.size(), m = (int)t.size();
		for (int i = 0; i < min(n, m); ++i) {
			if (s[i] != t[i]) {
				if (n == m) return s.substr(i + 1) == t.substr(i + 1);
				else if (n < m) return s.substr(i) == t.substr(i + 1);
				else return s.substr(i + 1) == t.substr(i);
			}
		}
		return (int)(abs(n - m)) == 1;
	}

	// 87. Scramble String [H][VH]
	// Given a string s1, we may represent it as a binary tree by partitioning it to two non-empty substrings recursively. To scramble the string, we may choose any non-leaf node and swap its two children. Given two strings s1 and s2 of the same length, determine if s2 is a scrambled string of s1.
	// Time: O(N^4)
	bool isScramble(string s1, string s2) {
		const int N = s1.size();
		if (s2.size() != N)
			return false;
		// length, starting i, starting j
		vector<vector<vector<bool>>> f(N + 1, vector<vector<bool>>(N, vector<bool>(N)));

		for (int i = 0; i < N; ++i)
			for (int j = 0; j < N; ++j)
				f[1][i][j] = (s1[i] == s2[j]);

		for (int n = 1; n <= N; ++n) {
			for (int i = 0; i + n <= N; ++i) {
				for (int j = 0; j + n <= N; ++j) {
					for (int k = 1; k < n; ++k) {
						if ((f[k][i][j] && f[n - k][i + k][j + k]) ||
							(f[k][i][j + n - k] && f[n - k][i + k][j])) {
							f[n][i][j] = true;
							break;
						}
					}
				}
			}
		}
		return f[N][0][0];
	}
	// I don't understand Du's solution
	// Below is a faster and easy-to-understand solution
	bool isScramble(string &s1, string &s2) {
		// write your code here

		/**
		 *   great
		 *   => atgre, eatgr
		 *             => tgrea
		 * 
		 *  A scrambled version of a string can be generated by interexchanging
		 *  its prefix and suffix. For example, "deabc" is derived from 
		 *  interexchaning "abc", the prefix, and "de", the suffix, of "abcde".
		 * 
		 *  Given 2 strings, S and T, we can determine if T is a scrambled version
		 *  of S by decompsing these 2 strings into 2 parts respectively and 
		 *  checking if these 2 substrings are equal:
		 * 
		 *      S = Sp + Ss
		 *      T = Tp + Ts
		 * 
		 *      => Sp == Tp && Ss == Ts, scrambled one!
		 *      => Sp == Ts && Ss == Tp, scrambled one!
		 */

		std::unordered_map<std::string, 
		    std::unordered_map<std::string, bool>> memo;
		return canScramble(s1, s2, memo);
	    }
	
	    bool canScramble(const auto& s, const auto& t, auto& memo) {
		// Check the cached result first.
		auto it_s = memo.find(s);
		if (it_s != memo.end()) {
		    auto& inner = it_s->second;
		    auto it_t = inner.find(t);
		    if (it_t != inner.end()) {
			return it_t->second;
		    }
		}

		// Check the string lengths.
		int n = s.length();
		int m = t.length();
		if (n != m) {
		    return false;
		}

		if (n == 1) {
		    bool res = s[0] == t[0];
		    memo[s][t] = res;
		    return res;
		}

		// Check the character composition.
		std::vector<int> freq_s(26, 0);
		std::vector<int> freq_t(26, 0);
		for (char ch : s) {
		    ++freq_s[ch - 'a'];
		}
		for (char ch : t) {
		    ++freq_t[ch - 'a'];
		}
		for (int i = 0 ; i < 26 ; ++i) {
		    if (freq_s[i] != freq_t[i]) {
			memo[s][t] = false;
			return false;
		    }
		}

		for (int i = 0 ; i < n - 1 ; ++i) {

		    int l = i + 1;
		    bool res = 
			(canScramble(s.substr(0, l), t.substr(0, l), memo) &&
			 canScramble(s.substr(l, n - l), t.substr(  l, n - l), memo)) ||
			(canScramble(s.substr(0, l), t.substr(n - l, l), memo) &&
			 canScramble(s.substr(l, n - l), t.substr(0, n - l), memo));

		    if (res) {
			memo[s][t] = true;
			return true;
		    }
		}
		memo[s][t] = false;
		return false;
	    }

	// 97. Interleaving String [H][VH]
	// Given s1, s2, s3, find whether s3 is formed by the interleaving of s1 and s2.
	/*
		Example 1:

		Input: s1 = "aabcc", s2 = "dbbca", s3 = "aadbbcbcac"
		Output: true
		Example 2:

		Input: s1 = "aabcc", s2 = "dbbca", s3 = "aadbbbaccc"
		Output: false
	*/
	bool isInterleave(string s1, string s2, string s3) {
		int N = s3.size();
		int m = s1.size();
		int n = s2.size();
		if (m + n != N) return false;
		vector<vector<bool>> f(N + 1, vector<bool>(m + 1, false));
		f[0][0] = true;

		for (int i = 1; i <= N; ++i) {
			f[i][0] = (f[i - 1][0] && s3[i - 1] == s2[i - 1]);
			printf("f[%d][%d] = %s\t", i, 0, f[i][0] ? "T" : "F");
			for (int j = 1; j <= i; ++j) {
				if (f[i - 1][j] && s3[i - 1] == s2[i - j - 1])
					f[i][j] = true;
				if (f[i - 1][j - 1] && s3[i - 1] == s1[j - 1])
					f[i][j] = true;
			}
		}
		return f[N][m];
	}
	// my recursion
	bool isInterleave(string s1, string s2, string s3) {
		if(s1.size() + s2.size() != s3.size())
		    return false;
		vector<vector<int>> cache(s1.size(), vector<int> (s2.size()));
		 return isInterleave(s1, s2,s3,0,0, cache);
	    }

	    bool isInterleave(string& s1, string&s2, string & s3, int s1start, int s2start, vector<vector<int>> & cache){
		if(s1.size() == s1start)
		    return s2.substr(s2start) == s3.substr(s1start+s2start);
		if(s2.size() == s2start)
		    return s1.substr(s1start) == s3.substr(s1start+s2start);
		if(cache[s1start][s2start] != 0)
		    return cache[s1start][s2start] == 1;
		bool b= false;

		if(s1[s1start] == s3[s1start+s2start])
		    b = isInterleave(s1, s2, s3, s1start+1, s2start, cache);
		if(!b && s2[s2start] == s3[s1start+s2start])
		    b = isInterleave(s1, s2, s3, s1start, s2start+1, cache);
		cache[s1start][s2start] = b ? 1 : -1;
		return b; 
	    }
	// DP after reading the solution
	bool isInterleave(string s1, string s2, string s3) {
		if(s1.size() + s2.size() != s3.size())
		    return false;
		if(s1.size() == 0)
		    return s2 == s3;
		if(s2.size() == 0)
		    return s1 == s3;

		vector<vector<bool>> memo(s1.size()+1, vector<bool> (s2.size()+1, false));
		memo[0][0] = true;
		for(int i = 0; i < s1.size()+1; i++){
		    for(int j = 0; j < s2.size()+1; j++){                
			if(i > 0 && s1[i-1] == s3[i+j-1])
			    memo[i][j] = memo[i-1][j];
			if(!memo[i][j] && j > 0 && s2[j-1] == s3[i+j-1])
			    memo[i][j] = memo[i][j-1];                
			//cout << i << "," << j << ":" << memo[i][j] << "\n";
		    }
		}

		return memo.back().back();        
	    }
}
